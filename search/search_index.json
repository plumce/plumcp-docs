{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"PluMCP","text":"<p>PluMCP is a low-dependency Clojure/ClojureScript library for making Model Context Protocol (MCP) clients and servers. Connect your business (data, process and software) with AI Language Models and AI Agents using MCP and this library.</p> Supported platforms <p> </p> <p> </p>"},{"location":"#why-consider-plumcp","title":"Why consider PluMCP?","text":"<ul> <li>Complete: Enjoy almost all non-deprecated MCP features and transports</li> <li>Reach: Clojure/ClojureScript reaches Java/JavaScript eco-systems</li> <li>Ergonomic: User-friendly API, automatic error-checking</li> <li>Light: Low dependency, Bring your own dependency</li> <li>Flexible: Composable design with configurable/overridable defaults</li> <li>Secure: OAuth 2.1 integrated with Streamable HTTP transport</li> </ul>"},{"location":"#status","title":"Status","text":"<ul> <li>Protocol version: 2025-06-18, 2025-03-26 (TODO: 2025-11-25)</li> <li>Protocol implementation: Asynchronous, Full-duplex, Concurrent</li> <li>Features: All non-deprecated client/server features supported</li> <li>Transports: STDIO, Streamable HTTP (optionally with OAuth 2.1)</li> </ul>"},{"location":"#transports","title":"Transports","text":"Platform STDIO Streamable HTTP Streamable HTTP+OAuth 2.1 Clojure/JVM MCP server Yes Yes Yes Clojure/JVM MCP client Yes Yes Yes ClojureScript/NodeJS MCP server Yes Yes Yes ClojureScript/NodeJS MCP client Yes Yes Yes ClojureScript/Browser MCP client -- Yes With customization only"},{"location":"#license","title":"License","text":"<p>Copyright \u00a9 2025-2026 Shantanu Kumar</p> <p>This program and the accompanying materials are made available under the terms of the Eclipse Public License 1.0 which is available at https://www.eclipse.org/legal/epl/epl-v10.html.</p>"},{"location":"dependencies/","title":"Dependencies","text":"<p>Platform (Java/Node) dependencies are already covered in Installation.</p>"},{"location":"dependencies/#modules","title":"Modules","text":"<p>This project have the following modules:</p> <pre><code>graph TD\n    plumcp.core-dev --&gt;|Dev support| plumcp.core\n    plumcp.core-auth --&gt;|Auth support| plumcp.core\n\n    subgraph D[JSON Codec - include any]\n        plumcp.core-json-charred[\"plumcp.core-json#8209;charred\"]\n        plumcp.core-json-cheshire[\"plumcp.core#8209;json#8209;cheshire\"]\n        plumcp.core-json-datajson[\"plumcp.core#8209;json#8209;datajson\"]\n        plumcp.core-json-jsonista[\"plumcp.core#8209;json#8209;jsonista\"]\n    end\n\n    D --&gt;|JSON Codec| plumcp.core</code></pre> <p>The root module <code>plumcp.core</code> is a common dependency of all other modules. Every module may have other dependencies to accomplish respective goals.</p>"},{"location":"dependencies/#project-dependencies","title":"Project dependencies","text":""},{"location":"dependencies/#minimum-required-dependencies","title":"Minimum required dependencies","text":"<ul> <li>Clojure 1.12</li> <li><code>plumcp.core</code></li> <li><code>plumcp.core.json-&lt;any&gt;</code> (transitively gets <code>plumcp.core</code>)</li> </ul> <p>With Leiningen, you get the <code>:dependencies</code> (resolved transitively) as specified in <code>project.clj</code>. With Shadow-CLJS, you get Clojure 1.12 and ClojureScript 1.12 out of the box.</p>"},{"location":"dependencies/#why-json-codec","title":"Why JSON-codec?","text":"<p>The Java platform does not include any JSON API, so you would need one of the JSON codec modules beside the <code>plumcp.core</code> module. This also applies to ClojureScript apps, though JavaScript hosts natively support JSON, because the CLJS compiler runs in the Java platform.</p>"},{"location":"dependencies/#module-dependencies","title":"Module dependencies","text":"<p>This library includes the following modules</p> <ul> <li>plumcp.core<ul> <li>Clojure/ClojureScript 1.12 (not pulled in)</li> </ul> </li> <li>plumcp.core-dev (Development support)<ul> <li>bling</li> <li>malli</li> </ul> </li> <li>plumcp.core-auth (Auth support)<ul> <li>Clojure: jose4j</li> <li>ClojureScript: jose</li> </ul> </li> </ul>"},{"location":"dependencies/#defaults","title":"Defaults","text":""},{"location":"dependencies/#default-http-serverclient","title":"Default HTTP server/client","text":"ClojureClojureScript <ul> <li>HTTP server: Java Module <code>jdk.httpserver</code></li> <li>HTTP client: Java Package <code>java.net.http</code></li> </ul> <ul> <li>HTTP server: Node.js <code>http</code> module</li> <li>HTTP client: JS <code>fetch</code> (Browser compatible)</li> </ul>"},{"location":"dependencies/#traffic-logger","title":"Traffic Logger","text":"<p>The traffic logger is a protocol implementation. There are no-op, compact and colourful loggers included for different purposes. You may supply a logger suitable for your project in MCP client or server scenario.</p>"},{"location":"dependencies/#jwt-validation-streamable-http-oauth-21","title":"JWT validation (Streamable HTTP + OAuth 2.1)","text":"<p>When opting to use Streamable HTTP with OAuth 2.1, you may want to use the JWT validation functions in the <code>core-auth</code> module, or any suitable replacement.</p>"},{"location":"installation/","title":"Installation","text":"<p>Please install the following software packages required for Clojure/ClojureScript.</p> <p>This documentation uses Leiningen and shadow-cljs for examples - you may choose any build tool that fits your purpose.</p>"},{"location":"installation/#for-development","title":"For Development","text":"ClojureClojure on GraalVMClojureScript <ul> <li>Java 21 or higher (OpenJDK derived)</li> <li>Leiningen (to follow this documentation)</li> </ul> <ul> <li>GraalVM (either Oracle or Community) - if your project is not suited for   GraalVM, consider alternatives e.g. jbundle</li> <li>Leiningen (to follow this documentation)</li> </ul> <ul> <li>Java 21 or higher (OpenJDK derived, for development only)</li> <li>Node.js 21 or higher (LTS preferable - or at your option, Bun.js)</li> </ul>"},{"location":"installation/#for-deployment","title":"For Deployment","text":"ClojureClojure on GraalVMClojureScript <ul> <li>Java 21 or higher (OpenJDK derived)</li> </ul> <ul> <li>None, if you have a native binary</li> </ul> <ul> <li>Node.js 21 or higher (LTS preferable - or at your option, Bun.js)</li> </ul>"},{"location":"navigation/","title":"Code Navigation","text":"<p>The PluMCP codebase is organized under various namespaces. Most of the public API is segregated under <code>plumcp.core.api.*</code> as listed below:</p> Namespace Description <code>plumcp.core.api.entity-gen</code> Generate MCP entities <code>plumcp.core.api.entity-support</code> MCP entities Convenience fns <code>plumcp.core.api.mcp-client</code> Running MCP client <code>plumcp.core.api.mcp-server</code> Running MCP server <p>The namespaces other than the public API are subject to change between releases.</p>"},{"location":"navigation/#developing-mcp-apps-in-a-code-editor","title":"Developing MCP apps in a Code editor","text":"<p>When developing MCP apps, it may be helpful to use an editor that lets you explore and navigate the dependency (PluMCP) source code. REPL-driven development is not necessary, but the ability to inspect and navigate the dependency namespaces may be useful.</p> <p>If you are new to Clojure, consider one of the following Clojure-LSP enabled editor options as per your choice:</p> <ul> <li>Visual Studio Code (or VSCodium) wth Calva</li> <li>IntelliJ IDEA with Clojure-LSP (or Cursive)</li> <li>Emacs with LSP-mode (and optionally CIDER)</li> <li>Neovim with Conjure</li> </ul> <p>Configuring an editor for your workflow is beyond the scope of this document. Please explore the editor options as appropriate.</p>"},{"location":"news/","title":"What's New?","text":""},{"location":"news/#2026-jan-29","title":"2026-Jan-29","text":"<p>PluMCP 0.1.0 is released. This is the first preview release on Clojars. Follow QuickStart to see how to use it.</p>"},{"location":"quickstart/","title":"Quickstart","text":"<p>This page will walk you through creating your first PluMCP server.</p>"},{"location":"quickstart/#prerequisites","title":"Prerequisites","text":"<p>Make sure you have installed the required software.</p>"},{"location":"quickstart/#1-create-the-mcp-server-app","title":"1. Create the MCP server app","text":"<p>Run the following commands in a terminal as follows:</p> ClojureClojure on GraalVMClojureScript <pre><code>lein new app hello-mcp-clj\ncd hello-mcp-clj\n</code></pre> <pre><code>lein new app hello-mcp-clj\ncd hello-mcp-clj\n</code></pre> <p>With Node.js: <pre><code>npx create-cljs-project hello-mcp-cljs\ncd hello-mcp-cljs\n</code></pre> With Bun.js: <pre><code>bunx create-cljs-project hello-mcp-cljs\ncd hello-mcp-cljs\n</code></pre></p>"},{"location":"quickstart/#2-addedit-the-dependencies","title":"2. Add/edit the dependencies","text":"<p>Edit the files as highlighted below:</p> ClojureClojure on GraalVMClojureScript project.clj<pre><code>(defproject hello-mcp-clj \"0.1.0-SNAPSHOT\"\n  :description \"FIXME: write description\"\n  :url \"https://example.com/FIXME\"\n  :dependencies [[org.clojure/clojure \"1.12.4\"]\n                 [io.github.plumce/plumcp.core-json-charred \"0.1.0\"]]\n  :main ^:skip-aot hello-mcp-clj.core\n  :target-path \"target/%s\"\n  :profiles {:uberjar\n             {:aot :all\n              :jvm-opts [\"-Dclojure.compiler.direct-linking=true\"]}})\n</code></pre> project.clj<pre><code>(defproject hello-mcp-clj \"0.1.0-SNAPSHOT\"\n  :description \"FIXME: write description\"\n  :url \"https://example.com/FIXME\"\n  :dependencies [[org.clojure/clojure \"1.12.4\"]\n                 [io.github.plumce/plumcp.core-json-charred \"0.1.0\"]\n                 [com.github.clj-easy/graal-build-time \"1.0.5\"]]\n  :main ^:skip-aot hello-mcp-clj.core\n  :target-path \"target/%s\"\n  :profiles {:uberjar {:aot :all\n                       :jvm-opts [\"-Dclojure.compiler.direct-linking=true\"]}\n             :dev {:plugins [[lein-shell \"0.5.0\"]]}}\n  :aliases\n  {\"native\"\n   [\"shell\"\n    \"native-image\"\n    \"-Ob\"\n    \"-H:+TraceNativeToolUsage\"\n    \"-H:+AllowIncompleteClasspath\"\n    \"--verbose\"\n    \"--no-fallback\"\n    \"--report-unsupported-elements-at-runtime\"\n    ;; add here the namespaces of the library to test separated by commas\n    \"--features=clj_easy.graal_build_time.InitClojureClasses\"\n    \"-jar\"\n    \"./target/uberjar/${:uberjar-name:-${:name}-${:version}-standalone.jar}\"\n    \"-H:Name=./target/${:name}\"]\n\n   \"run-native\" [\"shell\" \"./target/${:name}\"]})\n</code></pre> shadow-cljs.edn<pre><code>;; shadow-cljs configuration\n{:source-paths\n [\"src/dev\"\n  \"src/main\"\n  \"src/test\"]\n\n :dependencies\n [[io.github.plumce/plumcp.core-json-charred \"0.1.0\"]]\n\n :builds\n {:app {:target :node-script\n        :main hello-mcp-cljs.core/main\n        :output-to \"out/node-server.js\"}}}\n</code></pre>"},{"location":"quickstart/#3-edit-the-sources","title":"3. Edit the sources","text":"<p>Add or edit the source files to add an MCP tool as follows:</p> ClojureClojure on GraalVMClojureScript src/hello_mcp_clj/core.clj<pre><code>(ns hello-mcp-clj.core\n  (:require [plumcp.core.api.entity-support :as es]\n            [plumcp.core.api.mcp-server :as ms])\n  (:gen-class))\n\n(def info (es/make-info \"Hello MCP Server\" \"0.1.0\"))\n\n(defn ^{:mcp-type :tool} add\n  \"Add two integers\"\n  [{:keys [^{:doc \"An integer\" :type \"integer\"} a\n           ^{:doc \"Another integer\" :type \"integer\"} b]}]\n  (str \"Sum of \" a \" and \" b \" is \" (+ a b)))\n\n(defn -main\n  [&amp; args]\n  (ms/run-server {:info info :transport :http}))\n</code></pre> src/hello_mcp_clj/core.clj<pre><code>(ns hello-mcp-clj.core\n  (:require [plumcp.core.api.entity-support :as es]\n            [plumcp.core.api.mcp-server :as ms])\n  (:gen-class))\n\n(def info (es/make-info \"Hello MCP Server\" \"0.1.0\"))\n\n(defn ^{:mcp-type :tool} add\n  \"Add two integers\"\n  [{:keys [^{:doc \"An integer\" :type \"integer\"} a\n           ^{:doc \"Another integer\" :type \"integer\"} b]}]\n  (str \"Sum of \" a \" and \" b \" is \" (+ a b)))\n\n(defn -main\n  [&amp; args]\n  (ms/run-server {:info info :transport :http}))\n</code></pre> <p>Create any missing/required directory: <pre><code>mkdir -p src/main/hello_mcp_cljs\n</code></pre> Then create this file as follows: src/main/hello_mcp_cljs/core.cljs<pre><code>(ns hello-mcp-cljs.core\n  (:require\n   [plumcp.core.api.entity-support :as es]\n   [plumcp.core.api.mcp-server :as ms]))\n\n(def info (es/make-info \"Hello MCP Server\" \"0.1.0\"))\n\n(defn ^{:mcp-type :tool} add\n  \"Add two integers\"\n  [{:keys [^{:doc \"An integer\" :type \"integer\"} a\n           ^{:doc \"Another integer\" :type \"integer\"} b]}]\n  (str \"Sum of \" a \" and \" b \" is \" (+ a b)))\n\n(defn main\n  [&amp; args]\n  (ms/run-server {:info info :transport :http}))\n</code></pre></p>"},{"location":"quickstart/#4-compilerun-the-mcp-server","title":"4. Compile/Run the MCP server","text":"ClojureClojure on GraalVMClojureScript <pre><code>lein run\n</code></pre> <pre><code>lein uberjar\nlein native\nlein run-native  # or ./target/hello-mcp-clj\n</code></pre> <p>Using Node.js: <pre><code>npx shadow-cljs compile :app\nnode out/node-server.js\n</code></pre> Using Bun.js: <pre><code>bunx shadow-cljs compile :app\nbun out/node-server.js\n</code></pre></p> <p>When the MCP server is up and running, you may connect using a suitable MCP client.</p>"},{"location":"mcpclient/","title":"PluMCP Client","text":"<p>The PluMCP client workflow:</p> <pre><code>flowchart TD\n    Start@{ shape: circle, label: \"Start\" }\n    A@{ shape: rounded, label: \"1. Make PluMCP client\" }\n    B@{ shape: rounded, label: \"2. Initialize\" }\n    C@{ shape: rounded, label: \"3. MCP client operation\" }\n    D@{ shape: rounded, label: \"4. Disconnect\" }\n    Stop@{ shape: dbl-circ, label: \"Stop\" }\n    Start--&gt;A\n    A--&gt;|Transport is started|B\n    B--&gt;|Session is established|C\n    C--&gt;|Next MCP Client Operation| C\n    C--&gt;|Want to end the client|D\n    D--&gt;|Session/Transport is stopped|Stop</code></pre> <p>The PluMCP Client API is contained in the <code>plumcp.core.api.mcp-client</code> namespace. Remainder of this page assumes you have these aliases setup.</p> <pre><code>(ns app.core\n  (:require [plumcp.core.api.entity-support :as es]\n            [plumcp.core.api.mcp-client :as mc]\n            [plumcp.core.client.http-client-transport :as hct]\n            [plumcp.core.client.stdio-client-transport :as sct]\n            [plumcp.core.support.http-client :as hc]))\n</code></pre>"},{"location":"mcpclient/#1-make-plumcp-client","title":"1. Make PluMCP client","text":"<pre><code>(def client-info (es/make-info \"My MCP app\" \"0.1.0\"))\n\n(def stdio-transport\n  (sct/run-command {:command-tokens [\"run-mcp-server\"]}))\n\n(def http-transport\n  (hct/make-streamable-http-transport\n   ((hc/make-http-client \"http://localhost:3000/mcp\"))))\n\n(def client-transport http-transport)  ; or stdio-transport\n\n(def the-client (mc/make-client {:info client-info\n                                 :client-transport client-transport}))\n</code></pre>"},{"location":"mcpclient/#2-initialize-the-client","title":"2. Initialize the client","text":"<p>MCP client initialization needs to be followed up with a notification of initialization, which you can do as follows:</p> <pre><code>(mc/initialize-and-notify! the-client)\n</code></pre> <p>If you want control over how/when notification happens, or you want to perform some step before sending notification, you may use the lower level API:</p> <pre><code>(mc/initialize! the-client\n                (fn [result]\n                  (mc/notify-initialized the-client)))\n</code></pre>"},{"location":"mcpclient/#3-mcp-client-operation","title":"3. MCP Client operation","text":"<p>The MCP Client operations have their corresponding API. Some of the API calls that accept client and a handler function as argument are shown below:</p> MCP Client Operation Client API call Arguments List MCP prompts <code>mc/list-prompts</code> <code>[client handler]</code> List MCP resources <code>mc/list-resources</code> <code>[client handler]</code> List MCP resource templates <code>mc/list-resource-templates</code> <code>[client handler]</code> List MCP tools <code>mc/list-tools</code> <code>[client handler]</code> Get MCP prompt <code>mc/get-prompt</code> <code>[client handler]</code> Read MCP resource <code>mc/read-resource</code> <code>[client handler]</code> Call MCP tool <code>mc/call-tool</code> <code>[client handler]</code> Complete (Completion) <code>mc/complete</code> <code>[client handler]</code> Ping <code>mc/ping</code> <code>[client handler]</code> <p>Note!</p> <p>This is a selected list of API calls - for exhaustive list check the source in <code>plumcp.core.api.mcp-client</code> namespace.</p> <p>For example, you can print the list the MCP tools as follows:</p> <pre><code>(mc/list-tools the-client (fn [tools]\n                            (println \"Tools\" tools)))\n</code></pre> <p>The <code>handler</code> is an arity-1 callback function that is invoked after the response for the client request arrives.</p>"},{"location":"mcpclient/#4-disconnect-the-client","title":"4. Disconnect the client","text":"<p>Disconnection of the client, which stops the transport, is quite straightforward:</p> <pre><code>(mc/disconnect! the-client)\n</code></pre> <p>Don't forget to disconnect</p> <p>Failing to disconnect the PluMCP client may keep the client transport running, holding on to resources, hence preventing cleanup.</p>"},{"location":"mcpclient/elicitation/","title":"MCP Elicitation","text":"<p>TODO</p>"},{"location":"mcpclient/oauth/","title":"OAuth 2.1 for Streamable HTTP Transport","text":"<p>TODO</p>"},{"location":"mcpclient/prompts/","title":"MCP Prompts (Client)","text":"<p>You can access the server-defined prompt templates using PluMCP client API. It is assumed that you would require and alias the client namespace as follows:</p> <pre><code>[plumcp.core.api.mcp-client :as mc]\n</code></pre>"},{"location":"mcpclient/prompts/#list-prompts","title":"List prompts","text":"<p>You can list the server-defined prompts using <code>list-prompts</code>:</p> <pre><code>(mc/list-prompts plumcp-client\n                 (fn [prompts]\n                   (println \"Prompts\" prompts)))\n</code></pre>"},{"location":"mcpclient/prompts/#get-prompt","title":"Get prompt","text":"<p>To get the prompt defined in Prompts (Server) by name the call would be:</p> <pre><code>(def query\n  \"What is the best way to learn about medicine as someone\n  who has no background in medicine?\")\n\n(mc/get-prompt plumcp-client\n               \"chain_of_verification\"\n               {:query query}\n               (fn [prompt-result]\n                 (println prompt-result)))\n</code></pre> <p>After you get the prompt result, you can use it to send a request to a suitable AI language model.</p>"},{"location":"mcpclient/prompts/#error-handling","title":"Error handling","text":"<p>If an error is encountered when getting a prompt, the error is printed on the screen by default. To handle the error you can specify an error response handler to the call:</p> <pre><code>(mc/get-prompt plumcp-client\n               \"chain_of_verification\"\n               {:query query}\n               (fn [prompt-result]\n                 (println prompt-result))\n               (fn [jsonrpc-error-response]\n                 ;; handle the error\n                 (println jsonrpc-error-response)))\n</code></pre> <p>Unlike the result (data), the error handler receives the entire JSON-RPC error response (map) - the error payload is located at the <code>:error</code> key.</p>"},{"location":"mcpclient/resources/","title":"MCP Resources (Client)","text":"<p>You can access the server-defined resources and resource-templates using PluMCP client API. It is assumed that you would require and alias the client namespace as follows:</p> <pre><code>[plumcp.core.api.mcp-client :as mc]\n</code></pre>"},{"location":"mcpclient/resources/#list-resources-and-resource-templates","title":"List resources and resource-templates","text":"<p>You can list the server-defined resources using <code>list-resources</code> and resource-templates using <code>list-resource-templates</code>:</p> <pre><code>(mc/list-resources plumcp-client\n                   (fn [resources]\n                     (println \"Resources\" resources)))\n\n(mc/list-resource-templates plumcp-client\n                            (fn [resource-templates]\n                              (println \"Resource templates\"\n                                       resource-templates)))\n</code></pre>"},{"location":"mcpclient/resources/#read-resource","title":"Read resource","text":"<p>To read the resource defined in Resources (Server) by name the call would be:</p> <pre><code>(mc/read-resource plumcp-client\n                  \"text://fire/safety\"\n                  (fn [resource-result]\n                    (println resource-result)))\n\n(mc/read-resource plumcp-client\n                  \"info://consumable/148\"\n                  (fn [resource-result]\n                    (println resource-result)))\n</code></pre>"},{"location":"mcpclient/resources/#error-handling","title":"Error handling","text":"<p>If an error is encountered when reading a resource, the error is printed on the screen by default. To handle the error you can specify an error response handler to the call:</p> <pre><code>(mc/read-resource plumcp-client\n                  \"info://consumable/148\"\n                  (fn [resource-result]\n                    (println resource-result))\n                  (fn [jsonrpc-error-response]\n                    ;; handle the error\n                    (println jsonrpc-error-response)))\n</code></pre> <p>Unlike the result (data), the error handler receives the entire JSON-RPC error response (map) - the error payload is located at the <code>:error</code> key.</p>"},{"location":"mcpclient/roots/","title":"MCP Roots","text":"<p>TODO</p>"},{"location":"mcpclient/sampling/","title":"MCP Sampling","text":"<p>TODO</p>"},{"location":"mcpclient/tools/","title":"MCP Tools (Client)","text":"<p>You can access the server-defined tools using PluMCP client API. It is assumed that you would require and alias the client namespace as follows:</p> <pre><code>[plumcp.core.api.mcp-client :as mc]\n</code></pre>"},{"location":"mcpclient/tools/#list-tools","title":"List tools","text":"<p>You can list the server-defined tools using <code>list-tools</code>:</p> <pre><code>(mc/list-tools plumcp-client\n               (fn [tools]\n                 (println \"Tools\" tools)))\n</code></pre>"},{"location":"mcpclient/tools/#call-tool","title":"Call tool","text":"<p>To call the tool defined in Tools (Server) by name the call would be:</p> <pre><code>(mc/call-tool plumcp-client\n              \"generate_demand_forecast\"\n              {\"part_number\" \"4588-RT-345\"\n               :weeks 4}\n              (fn [demand-forecast]\n                (println demand-forecast)))\n</code></pre> <p>After you get the call-tool result, you can parse and destructure it to suit your AI use case.</p>"},{"location":"mcpclient/tools/#error-handling","title":"Error handling","text":"<p>If an error is encountered when calling a tool, the error is printed on the screen by default. To handle the error you can specify an error response handler to the call:</p> <pre><code>(mc/call-tool plumcp-client\n              \"generate_demand_forecast\"\n              {\"part_number\" \"4588-RT-345\"\n               :weeks 4}\n              (fn [demand-forecast]\n                (println demand-forecast))\n              (fn [jsonrpc-error-response]\n                ;; handle the error\n                (println jsonrpc-error-response)))\n</code></pre> <p>Unlike the result (data), the error handler receives the entire JSON-RPC error response (map) - the error payload is located at the <code>:error</code> key.</p>"},{"location":"mcpserver/","title":"PluMCP Server","text":"<p>As we saw in Quickstart the main entrypoint of PluMCP Server is function <code>plumcp.core.api.mcp-server/run-server</code>, which accepts several options.</p> <p>Below are few common options (check source for exhaustive list):</p> <ul> <li><code>:info</code> (required) is MCP server info, may be constructed   using <code>plumcp.core.api.entity-support/make-info</code></li> <li><code>:instructions</code> (optional) is a text communicated by the server   to the client</li> <li><code>:transport</code> (optional) is either <code>:stdio</code> (default) or <code>:http</code></li> <li><code>:runtime</code> (optional) is derived from other args if unspecified<ul> <li><code>:capabilities</code> (optional) is constructed from options below<ul> <li><code>:primitives</code> (optional) is a map with keys   <code>:prompts</code>, <code>:resources</code>, <code>:tools</code>, <code>:callbacks</code></li> <li><code>:vars</code> (optional) is a vector of annotated var instances</li> <li><code>:ns</code> (optional, default: current namespace) is a vector   of namespaces</li> </ul> </li> </ul> </li> </ul> <p>Server capabilities</p> <p>A PluMCP server makes use of server capabilities to deliver its features. There are several ways to expose server capabilities. While <code>:primitives</code> is the low-level way to specify capabilities, <code>:vars</code> and <code>:ns</code> allow the use of annotated vars to discover capabilities.</p> <p>When you specify <code>{:ns [myapp.foo myapp.bar]}</code> it searches through all annotated vars in those namespaces to discover the primitives. Similarly, specifying <code>{:vars [#'myapp.foo/baz #'myapp.bar/quux]}</code> causes only those annotated vars to be scanned as primitives.</p>"},{"location":"mcpserver/#runing-an-stdio-server","title":"Runing an STDIO server","text":"<pre><code>(plumcp.core.api.mcp-server/run-server\n  {:info server-info\n   :transport :stdio     ; optional\n   :instructions \"...\"   ; optional\n   :ns [app.foo app.bar] ; optional\n   })\n</code></pre>"},{"location":"mcpserver/#running-streamable-http-server","title":"Running Streamable HTTP server","text":"<pre><code>(plumcp.core.api.mcp-server/run-server\n  {:info server-info\n   :transport :http      ; implies Streamable HTTP server\n   :instructions \"...\"   ; optional\n   :ns [app.foo app.bar] ; optional\n   })\n</code></pre>"},{"location":"mcpserver/callbacks/","title":"PluMCP Server Callbacks","text":"<p>TODO</p>"},{"location":"mcpserver/completion/","title":"MCP Completion","text":"<p>TODO</p>"},{"location":"mcpserver/logging/","title":"MCP Logging","text":"<p>TODO</p>"},{"location":"mcpserver/oauth/","title":"OAuth 2.1 for Streamable HTTP Transport","text":"<p>TODO</p>"},{"location":"mcpserver/prompts/","title":"MCP Prompts (Server)","text":"<p>Prompts are parameterized message templates meant to construct LLM prompts at the MCP-Client end. MCP clients lookup prompts from the MCP server and with user-consent, pass parameters and end up with the complete prompt to be sent to the LLM.</p> <p>Why Prompts?</p> <p>Imagine, you have an \"AI assistant\" app that responds to user input. You are not going to send the user input directly as a prompt to the LLM - you would rather extract the intent and other contextual metadata from the user input, then structure a prompt (based on a template) as per your use cases in order to fetch a response.</p> <p>Prompts are useful to model such templates. You can create an entire library of prompts for various use cases in your MCP Server.</p> <p>Here is a simple Chain of Verification (CoVe) prompt example.</p> <pre><code>(ns hello-mcp-clj.prompt\n  (:require\n   [plumcp.core.api.entity-gen :as eg]\n   [plumcp.core.schema.schema-defs :as sd]))\n\n\n(def cove-steps\n  \"Step 1. Provide your initial answer\nStep 2. Generate 3 to 5 sub-questions that would test the main answer's facts\nStep 3. Provide answers to each of those verification questions on their own\nStep 4. Provide a revised answer to the original question based on those checks\n\")\n\n\n;; Ref: https://arxiv.org/abs/2309.11495\n;; YTV: https://www.youtube.com/watch?v=MKU-Aeg_lBk\n(defn ^{:mcp-name \"chain_of_verification\"\n        :mcp-type :prompt} cove\n  \"Generate a Chain of Verification (CoVe) prompt for a given query.\"\n  [{:keys [^{:doc \"User query\"\n             :type \"string\"} query]}]\n  (eg/make-get-prompt-result\n   [(eg/make-prompt-message\n     sd/role-user\n     (eg/make-text-content\n      (str query\n           \"\\n\"\n           cove-steps)))]))\n</code></pre> <p>Client call</p> <p>See Prompts (Client) for the client call.</p>"},{"location":"mcpserver/prompts/#prompt-var-definition","title":"Prompt Var definition","text":"<p>As you can see in the highlighted code example above, var annotations convey the prompt metadata:</p> <ul> <li><code>:mcp-name</code> (optional) The MCP prompt name - same as function name   if unspecified</li> <li><code>:mcp-type</code> <code>:prompt</code> indicates that this is an MCP prompt</li> <li>The function docstring acts as the prompt description</li> <li>An MCP primitive var is always an arity-1 function. The argument is   a map of specified, annotated keyword args. In the example above -   <code>query</code> is a prompt argument with specified <code>:doc</code> (description) and   <code>:type</code> (JSON type) annotations.</li> <li>The function is called when MCP <code>get-prompt</code> method is invoked. The   function body is supposed to return a <code>get-prompt result</code>, which is   done above by the <code>plumcp.core.api.entity-gen/make-get-prompt-result</code>   function.</li> </ul> <p>Prompts can range from simple, rudimentary to complex, few-shot instances, depending upon the use case. Prompts are important feature of MCP servers to build capable agentic AI applications.</p>"},{"location":"mcpserver/resources/","title":"MCP Resources (Server)","text":"<p>An MCP Resource is a URI-addressable, read-only, text or binary payload of data at the MCP server that a model is allowed to see. The resource content is tagged with a MIME-type to describe the content type.</p> <p>Internally, a resource is a data abstraction backed by static or dynamic content in storage and discovery. Examples of resources are user-profile data, a database schema, business configuration, business knowledge documents etc.</p> <p>Resource vs Resource template - Difference only in exposure</p> <p>Resources may be exposed as MCP server capability in either of two ways:</p> <ul> <li>Resource: has fixed URI, e.g. <code>worksheet://acct/2026/1351</code></li> <li>Resource Template: has URI template, e.g. <code>workorder://shopfloor/2026/{id}</code></li> </ul> <p>The MCP <code>read-resource</code> call contains a full URI that automatically maps to either a matching resource or a matching resource template.</p> <p>Here are resource and resource template examples:</p> <pre><code>(ns hello-mcp-clj.resource\n  (:require\n   [plumcp.core.api.entity-support :as es]\n   [plumcp.core.util :as u]))\n\n\n(defn get-fire-safety-instructions []\n  ;; Simulate loading fire safety instructions from storage\n  \"Fire safety instructions\")\n\n\n(defn ^{:mcp-type :resource\n        :mcp-name \"fire_safety_instructions\"\n        :mime-type \"text/plain\"} fire-safety\n  \"Fire safety instructions for the shopfloor\"\n  [{:keys [^{:doc \"text://fire/safety\"} uri]}]\n  (es/make-text-resource-result\n   uri\n   (get-fire-safety-instructions)))\n\n\n(defn get-consumable-info [id]\n  ;; Simulate load consumable info from database\n  {:part-no \"ABC123\"\n   :description \"Disinfectant wipe\"\n   :batch-no \"56/2024\"\n   :life-upto \"2025/06\"})\n\n\n(defn ^{:mcp-type :resource-template\n        :mcp-name \"consumable_info\"\n        :mime-type \"application/json\"} consumable-info\n  \"Consumable info as JSON\"\n  [{:keys [^{:doc \"info://consumable/{id}\"} uri\n           ^{:doc \"URI params\"} params]}]\n  (-&gt;&gt; (get-consumable-info (:id params))\n       u/json-write\n       (es/make-text-resource-result uri)))\n</code></pre> <p>Client call</p> <p>See Resources (Client) for the client call.</p>"},{"location":"mcpserver/resources/#resource-var-definition","title":"Resource Var definition","text":"<p>As you can see in the highlighted code example above, var annotations convey the resource metadata:</p> <ul> <li><code>:mcp-name</code> (optional) The MCP resource name - same as function name   if unspecified</li> <li><code>:mcp-type</code> <code>:resource</code> indicates that this is an MCP resource</li> <li><code>:mcp-type</code> <code>:resource-template</code> indicates this is an MCP resource   template</li> <li>The function docstring acts as the resource description</li> <li>An MCP primitive var is always an arity-1 function. The argument is   a map of specified, annotated keyword args. In the example above -   <code>uri</code> (and <code>params</code> for resource templates) are resource arguments   with specified <code>:doc</code> (URI or URI-template for <code>uri</code>, docstring for   <code>params</code>) annotations.</li> <li>The function is called when MCP <code>read-resource</code> method is invoked. The   function body is supposed to return a <code>read-resource result</code>, which is   done above by the <code>plumcp.core.api.entity-support/make-text-resource-result</code>   function.</li> </ul> <p>Resources can be put to good use by offloading business and contextual knowledge base, and other data as resources. This helps make AI Agents lightweight where they depend on MCP servers to do this heavy lifting.</p>"},{"location":"mcpserver/ring-adapter/","title":"Ring Adapter for Streamable HTTP Transport","text":"<p>TODO</p>"},{"location":"mcpserver/tools/","title":"MCP Tools (Server)","text":"<p>An MCP tool represents an action that a model may be allowed to invoke. In the LLM context, MCP tools may be described as actions that the LLM may know and choose to prescribe to achieve a certain goal.</p> <p>Tools are the MCP server workhorse</p> <p>Tools are commonly the biggest use case for MCP servers. The tools encapsulate the interface to business systems and implementation that MCP clients can access.</p> <p>From an implementation perspective, tools are remote functions invoked over the MCP protocol. MCP clients specify the tool name and arguments to call the tool.</p> <p>As you may have seen in Quickstart a tool is composed of the tool metadata and a handler function. Let us see another tool example:</p> <pre><code>(ns hello-mcp-clj.tool\n  (:require\n   [plumcp.core.api.entity-gen :as eg]\n   [plumcp.core.util :as u]))\n\n\n(defn get-forecast\n  [part-no weeks]\n  ;; Call internal function to generate the data\n  {:part-number \"4588-RT-345\"\n   :description \"O Ring Heat-resistant Grade-3\"\n   :quantity 28\n   :denomination \"each\"})\n\n\n(defn ^{:mcp-name \"generate_demand_forecast\"\n        :mcp-type :tool} demand-forecast\n  \"Generate demand forecast for specified equipment\"\n  [{:keys [^{:name \"part_number\"\n             :doc \"Equipment part number\" :type \"string\"} part-no\n           ^{:doc \"Forecast weeks count\" :type \"integer\"\n             :default 3 :minimum 1 :maximum 8} weeks]}]\n  (let [fc (get-forecast part-no weeks)]\n    (eg/make-call-tool-result\n     [(eg/make-text-content (u/json-write fc))])))\n</code></pre> <p>Client call</p> <p>See Tools (Client) for the client call.</p>"},{"location":"mcpserver/tools/#tool-var-definition","title":"Tool Var definition","text":"<p>As you can see in the highlighted code example above, var annotations convey the tool metadata whereas the function itself produces the result:</p> <ul> <li><code>:mcp-name</code> (optional) The MCP tool name - same as function name   if unspecified</li> <li><code>:mcp-type</code> <code>:tool</code> indicates that this is an MCP tool</li> <li>The function docstring acts as the tool description</li> <li>An MCP primitive var is always an arity-1 function. The argument is   a map of specified, annotated keyword args. In the example above -   <code>part-no</code> and <code>weeks</code> are tool arguments with specified <code>:name</code> (name,   optional), <code>:doc</code> (description) and <code>:type</code> (JSON type) annotations.   The <code>:default</code>, <code>:minimum</code> and <code>:maximum</code> hints are for UI hints.</li> <li>The function is called when MCP <code>call-tool</code> method is invoked. The   function body is supposed to return a <code>call-tool result</code>, which is   done above by the <code>plumcp.core.api.entity-gen/make-call-tool-result</code>   function.</li> </ul> <p>In practice, tools are very business specific. Since AI Agents are associated with natural language the tool implementations often need to incorporate search (e.g. similar text) along with their business implementation.</p>"}]}